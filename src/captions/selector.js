const LANGUAGE_GROUPS = Object.freeze({
  ENGLISH: "en",
  ZH_HANT: "zh-hant",
  ZH_HANS: "zh-hans"
});

const TRADITIONAL_CODES = new Set([
  "zh-hant",
  "zh-tw",
  "zh-hk",
  "zh-mo",
  "zh-cht"
]);

const SIMPLIFIED_CODES = new Set([
  "zh-hans",
  "zh-cn",
  "zh-sg",
  "zh-chs"
]);

const normalizeLanguageCode = (code) => {
  if (!code || typeof code !== "string") {
    return "";
  }
  return code.trim().toLowerCase().replace(/_/g, "-");
};

const toLanguageGroup = (code) => {
  const normalized = normalizeLanguageCode(code);
  if (!normalized) {
    return "";
  }

  if (normalized === LANGUAGE_GROUPS.ENGLISH || normalized.startsWith("en-")) {
    return LANGUAGE_GROUPS.ENGLISH;
  }

  if (TRADITIONAL_CODES.has(normalized)) {
    return LANGUAGE_GROUPS.ZH_HANT;
  }

  if (SIMPLIFIED_CODES.has(normalized)) {
    return LANGUAGE_GROUPS.ZH_HANS;
  }

  const base = normalized.split("-")[0];
  if (base === "zh") {
    return "zh";
  }

  return normalized;
};

const getTrackLanguageCode = (track) => {
  if (!track || typeof track !== "object") {
    return "";
  }
  return track.languageCode || track.vssId || "";
};

const isAutoGenerated = (track) => track && track.kind === "asr";

const normalizeTrack = (track) => {
  if (!track || typeof track !== "object") {
    return null;
  }

  const rawCode = getTrackLanguageCode(track);
  const languageCode = normalizeLanguageCode(rawCode);

  return Object.freeze({
    languageCode,
    languageGroup: toLanguageGroup(languageCode),
    name: track.name && track.name.simpleText ? track.name.simpleText : "",
    kind: track.kind || "",
    isAuto: isAutoGenerated(track),
    baseUrl: track.baseUrl || "",
    vssId: track.vssId || "",
    isTranslatable: track.isTranslatable !== false
  });
};

const toTlangCode = (language) => {
  if (!language || typeof language !== "string") {
    return "";
  }

  const trimmed = language.trim();
  if (!trimmed) {
    return "";
  }

  const normalized = normalizeLanguageCode(trimmed);
  if (!normalized) {
    return "";
  }

  if (normalized === "zh-hant" || normalized === "zh-tw" || normalized === "zh-hk") {
    return "zh-Hant";
  }

  if (normalized === "zh-hans" || normalized === "zh-cn" || normalized === "zh-sg") {
    return "zh-Hans";
  }

  return normalized;
};

const isTranslatable = (track) => track && track.isTranslatable !== false;

const buildTranslatedTrack = (track, targetLanguage) => {
  if (!track || !track.baseUrl || !isTranslatable(track)) {
    return null;
  }

  const target = toTlangCode(targetLanguage);
  if (!target) {
    return null;
  }

  const url = new URL(track.baseUrl);
  url.searchParams.set("tlang", target);

  return Object.freeze({
    ...track,
    languageCode: target,
    languageGroup: toLanguageGroup(target),
    baseUrl: url.toString()
  });
};

const getAvailableTracks = (playerResponse) => {
  if (!playerResponse || typeof playerResponse !== "object") {
    return [];
  }

  const tracks =
    playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];

  if (!Array.isArray(tracks)) {
    return [];
  }

  return tracks
    .map(normalizeTrack)
    .filter((track) => track && track.languageCode);
};

const matchesLanguage = (track, targetLanguage) => {
  const targetGroup = toLanguageGroup(targetLanguage);
  if (!targetGroup) {
    return false;
  }

  if (track.languageGroup === targetGroup) {
    return true;
  }

  if (targetGroup === LANGUAGE_GROUPS.ZH_HANT) {
    return track.languageGroup === "zh" && TRADITIONAL_CODES.has(track.languageCode);
  }

  if (targetGroup === LANGUAGE_GROUPS.ZH_HANS) {
    return track.languageGroup === "zh" && SIMPLIFIED_CODES.has(track.languageCode);
  }

  return false;
};

const pickTrack = (tracks, targetLanguage, preferAuto) => {
  const candidates = tracks.filter((track) => matchesLanguage(track, targetLanguage));
  if (candidates.length === 0) {
    return null;
  }

  const autoCandidates = candidates.filter((track) => track.isAuto);
  if (preferAuto && autoCandidates.length > 0) {
    return autoCandidates[0];
  }

  return candidates[0];
};

const selectDualTracks = (tracks, settings) => {
  const safeTracks = Array.isArray(tracks) ? tracks : [];
  const primaryLang = settings && settings.primaryLang ? settings.primaryLang : "en";
  const secondaryLang = settings && settings.secondaryLang ? settings.secondaryLang : "zh-Hant";

  const primary = pickTrack(safeTracks, primaryLang, true);
  let secondary = pickTrack(safeTracks, secondaryLang, true);

  if (!secondary && primary && isTranslatable(primary)) {
    secondary = buildTranslatedTrack(primary, secondaryLang);
  }

  const reason = {
    primary: primary ? "selected" : "missing",
    secondary: secondary ? "selected" : "missing"
  };

  return { primary, secondary, reason };
};

export {
  getAvailableTracks,
  selectDualTracks,
  normalizeLanguageCode,
  toLanguageGroup,
  matchesLanguage
};
